---
title: 10. It Also Depends On the List
---

# dependency

``` cicada
import { Nat, nat_rec, nat_ind } from "./02.md"
import { zero, one, two, three, four, five, six, seven, eight, nine, ten } from "./02.md"
import { List } from "./05.md"
import { Vector } from "./06.md"
```

# Some examples of `Sigma` type

About `Equal` of `String`.

``` cicada
the(Type, [bread: String | Equal(String, bread, "bagel")])

the(
  [bread: String | Equal(String, bread, "bagel")],
  cons("bagel", refl))
```

About `[T: Type | T]`.

``` cicada
the(Type, [T: Type | T])
the([T: Type | T], cons(Nat, one))
the([T: Type | T], cons(String, "a"))

import { add } from "./03.md"

the([T: Type | T], cons((Nat) -> Nat, add(six)))
```

About `Equal` of `List`.

``` cicada
the(
  [food: String | Equal(List(String), List.cons(food, List.null), List.cons("toast", List.null))],
  cons("toast", refl))
```

About `Equal` of `Vector`.

``` cicada
import { peas } from "./07.md"

the(
  [length: Nat | Vector(String, length)],
  cons(six, peas(six)))

the(
  [length: Nat | Vector(String, length)],
  cons(two, Vector.cons("toast-and-jam", Vector.cons("tea", Vector.null))))
```

# Reading `Pair` and `Sigma` as statement

`Pair(A, D)` can be read as `A and D`.

For example `2 equals 3 and "apple" equals "apple"`,
can be expressed by `Pair(A, D)` as:

``` cicada
the(Type, Pair(Equal(Nat, two, three), Equal(String, "apple", "apple")))
```

`[x: A | D]` can be read as `there exists A, such that D`.

For example `there exists a list of string that equals to its own reverse`,
can be expressed by `[x: A | D]` as:

``` cicada
import { reverse } from "./05.md"

let symmetric_list_t: Type = [
  list: List(String) |
  Equal(List(String), list, reverse(String, list))
]

the(symmetric_list_t, cons(List.null, refl))
the(symmetric_list_t, cons(List.cons("S", List.cons("O", List.cons("S", List.null))), refl))
the(symmetric_list_t, cons(List.cons("A", List.cons("B", List.cons("B", List.cons("A", List.null)))), refl))
```

There exists a list of strings such that adding "grape" to the back or the front does the same thing.

``` cicada
import { list_cons_back } from "./05.md"

let magic_grapes_t: Type = [
  list: List(String) |
  Equal(List(String), list_cons_back(String, list, "grape"), List.cons("grape", list))
]

the(magic_grapes_t, cons(List.null, refl))
the(magic_grapes_t, cons(List.cons("grape", List.null), refl))
the(magic_grapes_t, cons(List.cons("grape", List.cons("grape", List.null)), refl))
```

# `replicate`

``` cicada
function replicate(E: Type, x: E, length: Nat): Vector(E, length) {
  function motive(target: Nat): Type {
    return Vector(E, target)
  }

  function step(prev: Nat, almost: Vector(E, prev)): Vector(E, Nat.add1(prev)) {
    return Vector.cons(x, almost)
  }

  return nat_ind(length, motive, Vector.null, step)
}

replicate(String, "hi", six)
```

# `vector_from_list`

Use a Specific Type for Correctness.
Specific types can rule out foolish definitions.

``` cicada
import { length } from "./05.md"

function vector_from_list(E: Type, list: List(E)): Vector(E, length(E, list)) {
  return induction (list) {
    (target) => Vector(E, length(E, target))
    case null => Vector.null
    case cons(head, _tail, almost) => Vector.cons(head, almost.tail)
  }
}

vector_from_list(Nat, List.null)
vector_from_list(Nat, List.cons(one, List.null))
vector_from_list(Nat, List.cons(one, List.cons(two, List.null)))
vector_from_list(Nat, List.cons(one, List.cons(two, List.cons(three, List.null))))
```
