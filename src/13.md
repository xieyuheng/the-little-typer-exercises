---
title: 13. Even Haf a Baker's Dozen
---

# dependency

``` cicada
import { List } from "./05.md"
```

# Either

``` cicada
datatype Either(L: Type, R: Type) {
  inl(left: L): Either(L, R)
  inr(right: R): Either(L, R)
}
```

# Use `Either` to express "or" as a type

``` cicada
the(Type, Either(Nat, String))
the(Either(Nat, String), Either.inl(6))
the(Either(Nat, String), Either.inr("abc"))
```

Let's use define a useless `size` to test induction of `Either`.

``` cicada
import { length } from "./05.md"

function size(either: Either(Nat, List(String))): Nat {
  return induction (either) {
    (_) => Nat
    case inl(n) => n
    case inr(list) => length(String, list)
  }
}

size(Either.inl(3))
size(Either.inr(List.cons("a", List.cons("b", List.cons("c", List.null)))))
```

# `even_or_odd`

Every natural number is even or odd.

``` cicada
import {
  Even,
  Odd,
  zero_is_even,
  // one_is_odd,
  even_add1_is_odd,
  odd_add1_is_even,
} from "./12.md"


function even_or_odd(n: Nat): Either(Even(n), Odd(n)) {
  function motive(target: Nat): Type {
    return Either(Even(target), Odd(target))
  }

  let base: Either(Even(0), Odd(0)) = Either.inl(zero_is_even)

  function step(
    prev: Nat,
    almost: Either(Even(prev), Odd(prev))
  ): Either(Even(add1(prev)), Odd(add1(prev))) {
    return induction (almost) {
      (_) => Either(Even(add1(prev)), Odd(add1(prev)))
      case inl(even) => Either.inr(even_add1_is_odd(prev, even))
      case inr(odd) => Either.inl(odd_add1_is_even(prev, odd))
    }
  }

  return nat_ind(n, motive, base, step)
}
```

Use "same-as" chart to find out the following values.

At each step, look for the parts of expressions that change and those that don't.
Try to identify motives, bases, and steps that appear multiple times.

``` cicada
even_or_odd(0)
even_or_odd(1)
even_or_odd(2)
even_or_odd(3)
even_or_odd(4)
even_or_odd(5)
even_or_odd(6)
even_or_odd(7)
```
