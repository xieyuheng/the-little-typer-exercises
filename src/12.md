---
title: 12. Even Numbers Can Be Odd
---

# `Even`

``` cicada
import { double } from "./09.md"

function Even(n: Nat): Type {
  return [half: Nat | Equal(Nat, n, double(half))]
}

let ten_is_even: Even(10) = cons(5, refl)
let zero_is_even: Even(0) = cons(0, refl)
```

Although two functions always return the same answer,
sometimes one of them is easier to use
because it more quickly becomes a value.

In particular, `add` and thus `twice`
leave an `add1` on the second argument,
while `double` puts both `add1`s at the top immediately.

**Carefully Choose Definitions**

Carefully-chosen definitions can greatly simplify later proofs.

# `even_add_2_is_even`

``` cicada
import { add } from "./03.md"
import { cong, cong_explicit } from "./08.md"

function even_add_2_is_even(n: Nat, even: Even(n)): Even(add(2, n)) {
  let half = car(even)
  let almost = cdr(even)
  // let evidence = cong_explicit(Nat, n, double(half), almost, Nat, add(2))
  let evidence = cong(almost, add(2))
  return cons(add1(half), evidence)
}

let two_is_even: Even(2) = even_add_2_is_even(0, zero_is_even)
```

# `Odd`

``` cicada
function Odd(n: Nat): Type {
  // `haf` is the half of the even number, that is one smaller than `n`.
  return [haf: Nat | Equal(Nat, n, add1(double(haf)))]
}

let eleven_is_odd: Odd(11) = cons(5, refl)
let one_is_odd: Odd(1) = cons(0, refl)
```

# `even_add1_is_odd`

``` cicada
function even_add1_is_odd(n: Nat, even: Even(n)): Odd(add1(n)) {
  let half = car(even)
  let almost = cdr(even)
  // let evidence = cong_explicit(Nat, n, double(half), almost, Nat, add(1))
  let evidence = cong(almost, add(1))
  return cons(half, evidence)
}
```

# `odd_add1_is_even`

``` cicada
function odd_add1_is_even(n: Nat, odd: Odd(n)): Even(add1(n)) {
  let haf = car(odd)
  let almost = cdr(odd)
  return cons(add1(haf), cong_explicit(Nat, n, add1(double(haf)), almost, Nat, add(1)))
}
```

# Behold! Ackermann!

``` cicada
function repeat(f: (Nat) -> Nat, n: Nat): Nat {
  return nat_rec(n, f(1), (_prev, almost) => f(almost))
}

function ackermann(n: Nat): (Nat) -> Nat {
  return nat_rec(n, add(1), (_prev, almost) => repeat(almost))
}

ackermann(0, 0)
ackermann(1, 0)
ackermann(2, 0)
ackermann(3, 0)

ackermann(0, 1)
ackermann(1, 1)
ackermann(2, 1)
ackermann(3, 1)

ackermann(0, 2)
ackermann(1, 2)
ackermann(2, 2)
ackermann(3, 2)

ackermann(0, 3)
ackermann(1, 3)
ackermann(2, 3)
ackermann(3, 3)
```
