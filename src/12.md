---
title: 12. Even Numbers Can Be Odd
---

# `Even`

``` cicada
import { Nat, nat_rec, nat_ind } from "./02.md"
import { zero, one, two, three, four, five, six, seven, eight, nine, ten } from "./02.md"
import { double } from "./09.md"

function Even(n: Nat): Type {
  return [half: Nat | Equal(Nat, n, double(half))]
}

let ten_is_even: Even(ten) = cons(five, refl)
let zero_is_even: Even(zero) = cons(zero, refl)
```

Although two functions always return the same answer,
sometimes one of them is easier to use
because it more quickly becomes a value.

In particular, `add` and thus `twice`
leave an `add1` on the second argument,
while `double` puts both `add1`s at the top immediately.

**Carefully Choose Definitions**

Carefully-chosen definitions can greatly simplify later proofs.

# `even_add_2_is_even`

``` cicada
import { add } from "./03.md"
import { cong, cong_explicit } from "./08.md"

function even_add_2_is_even(n: Nat, even: Even(n)): Even(add(two, n)) {
  let half = car(even)
  let almost = cdr(even)
  // let evidence = cong_explicit(Nat, n, double(half), almost, Nat, add(2))
  let evidence = cong(almost, add(two))
  return cons(Nat.add1(half), evidence)
}

let two_is_even: Even(two) = even_add_2_is_even(zero, zero_is_even)
```

# `Odd`

``` cicada
function Odd(n: Nat): Type {
  // `haf` is the half of the even number, that is one smaller than `n`.
  return [haf: Nat | Equal(Nat, n, Nat.add1(double(haf)))]
}

let eleven_is_odd: Odd(Nat.add1(ten)) = cons(five, refl)
let one_is_odd: Odd(one) = cons(zero, refl)
```

# `even_add1_is_odd`

``` cicada
function even_add1_is_odd(n: Nat, even: Even(n)): Odd(Nat.add1(n)) {
  let half = car(even)
  let almost = cdr(even)
  let evidence = cong(almost, add(one))
  return cons(half, evidence)
}
```

# `odd_add1_is_even`

``` cicada
function odd_add1_is_even(n: Nat, odd: Odd(n)): Even(Nat.add1(n)) {
  let haf = car(odd)
  let almost = cdr(odd)
  return cons(Nat.add1(haf), cong_explicit(Nat, n, Nat.add1(double(haf)), almost, Nat, add(one)))
}
```

# Behold! Ackermann!

``` cicada
function repeat(f: (Nat) -> Nat, n: Nat): Nat {
  return nat_rec(n, f(one), (_prev, almost) => f(almost))
}

function ackermann(n: Nat): (Nat) -> Nat {
  return nat_rec(n, add(one), (_prev, almost) => repeat(almost))
}

ackermann(zero, zero)
ackermann(one, zero)
ackermann(two, zero)
ackermann(three, zero)

ackermann(zero, one)
ackermann(one, one)
ackermann(two, one)
ackermann(three, one)

ackermann(zero, two)
ackermann(one, two)
ackermann(two, two)
ackermann(three, two)

ackermann(zero, three)
ackermann(one, three)
ackermann(two, three)
ackermann(three, three)
```
