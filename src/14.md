---
title: 14. There's Safety in Numbers
---

# dependency

``` cicada
import { List, list_rec } from "./05.md"
```

# `Maybe`

In order to pick a specific entry from a list,
we must know what to do when there are not enough entries.

One might say that there may be an entry, but there also may not be.

``` cicada
function Maybe(E: Type): Type {
  return Either(E, Trivial)
}

function nothing(E: Type): Maybe(E) {
  return inr(sole)
}

function just(E: Type, x: E): Maybe(E) {
  return inl(x)
}

the(Maybe(Nat), nothing(Nat))
the(Maybe(Nat), just(Nat, 1))
the(Maybe(Nat), just(Nat, 2))
the(Maybe(Nat), just(Nat, 3))
```

# `maybe_head` & `maybe_tail`

``` cicada
function maybe_head(E: Type, list: List(E)): Maybe(E) {
  return list_rec(
    list,
    nothing(E),
    (head, _tail, _almost) => just(E, head))
}

maybe_head(String, List.null)
maybe_head(String, List.cons("a", List.null))
maybe_head(String, List.cons("a", List.cons("b", List.null)))
maybe_head(String, List.cons("a", List.cons("b", List.cons("c", List.null))))

function maybe_tail(E: Type, list: List(E)): Maybe(List(E)) {
  return list_rec(
    list,
    nothing(List(E)),
    (_head, tail, _almost) => just(List(E), tail))
}

maybe_tail(String, List.null)
maybe_tail(String, List.cons("a", List.null))
maybe_tail(String, List.cons("a", List.cons("b", List.null)))
maybe_tail(String, List.cons("a", List.cons("b", List.cons("c", List.null))))
```

# `list_ref`

``` cicada
function list_ref_step(E: Type, prev: Nat, almost: (List(E)) -> Maybe(E)): (List(E)) -> Maybe(E) {
  return (list) =>
    either_ind(
      maybe_tail(E, list),
      (_) => Maybe(E),
      (tail) => almost(tail),
      (_) => nothing(E))
}

function list_ref(E: Type, index: Nat): (List(E)) -> Maybe(E) {
  return nat_rec(index, maybe_head(E), list_ref_step(E))
}

list_ref(String, 0, List.cons("a", List.cons("b", List.cons("c", List.null))))
list_ref(String, 1, List.cons("a", List.cons("b", List.cons("c", List.null))))
list_ref(String, 2, List.cons("a", List.cons("b", List.cons("c", List.null))))
list_ref(String, 3, List.cons("a", List.cons("b", List.cons("c", List.null))))
list_ref(String, 4, List.cons("a", List.cons("b", List.cons("c", List.null))))
```

# `Fin`

To define `vector_ref` a new type is needed:
one that represents only numbers smaller than the length of the `Vector`.

We will define type `Fin(n)` to represents "The set of finite natural number smaller than n".

The type of `Fin(0)` is absurd, let's play with absurd first.

``` cicada
function similarly_absurd(x: Absurd): Absurd {
  return x
}

similarly_absurd
```

**The Commandment of Absurdities**

Every expression of type Absurd is neutral, and all of them are the same.

Now let's define `Fin`.

The strategy here is to make use of algebric-ness of types,
to define a type with `n` elements -- the cardinal.

We note that `cardinal(Maybe(x)) = 1 + cardinal(x)`, thus we use `Maybe` in the step.

``` cicada
function Fin(n: Nat): Type {
  let base: Type = Absurd

  function step(prev: Nat, almost: Type): Type {
    return Maybe(almost)
  }

  return nat_rec(n, base, step)
}

Fin(0)
Fin(1)
Fin(2)
Fin(3)
```

We will use elements of `Fin(n)` to index elements of `Vector(E, add1(n))`.

The first entry in a `Vector(E, addl(n))` is indexed by `fzero(n)`.

We can construct a value for each `Fin(n)` where `n` is greater than zero.
We call this construction `fzero`, because it represents zero
of each "set of finite natural number smaller than n".

``` cicada
function fzero(n: Nat): Fin(add1(n)) {
  return nothing(Fin(n))
}

fzero(0)
fzero(1)
fzero(2)
fzero(3)
```

Just as `fzero(n)` points at the head of a `Vector(X, addl(n))`,
`faddl` points somewhere in its tail.

For each layer of `Maybe` in the type,
there is a choice between either stopping
with `fzero` (also known as `nothing`) and
continuing with `just` a value from the
smaller type.

``` cicada
function fadd1(n: Nat, prev: Fin(n)): Fin(add1(n)) {
  return just(Fin(n), prev)
}

fadd1(1, fzero(0))
fadd1(2, fadd1(1, fzero(0)))
fadd1(3, fadd1(2, fadd1(1, fzero(0))))

fadd1(11, fzero(10))
fadd1(12, fadd1(11, fzero(10)))
fadd1(13, fadd1(12, fadd1(11, fzero(10))))
```

We can also defind `fin_ind`, instead of using `either_ind` directly.

``` cicada
function fin_which(
  prev: Nat,
  finite: Fin(add1(prev)),
  T: Type,
  base: T,
  step: (fprev: Fin(prev)) -> T,
): T {
  function motive(target: Fin(add1(prev))): Type {
    return T
  }

  function base_left(fprev: Fin(prev)): T {
    return step(fprev)
  }

  function base_right(_: Trivial): T {
    return base
  }

  return either_ind(finite, motive, base_left, base_right)
}
```

# `vector_ref`

``` cicada
function vector_ref(E: Type, length: Nat): (Fin(length), Vector(E, length)) -> E {
  function motive(target: Nat): Type {
    return (Fin(target), Vector(E, target)) -> E
  }

  let base: (Fin(0), Vector(E, 0)) -> E =
    (index, vector) => absurd_ind(index, E)

  function step(
    prev: Nat,
    almost: (Fin(prev), Vector(E, prev)) -> E
  ): (Fin(add1(prev)), Vector(E, add1(prev))) -> E {
    return (index, vector) => {
      let base: E = vector_head(vector)

      function step(prev: Fin(prev)): E {
        return almost(prev, vector_tail(vector))
      }

      return fin_which(prev, index, E, base, step)
    }
  }

  return nat_ind(length, motive, base, step)
}


vector_ref(String, 3, fzero(2), vec! ["a", "b", "c"])
vector_ref(String, 3, fadd1(2, fzero(1)), vec! ["a", "b", "c"])
vector_ref(String, 3, fadd1(2, fadd1(1, fzero(0))), vec! ["a", "b", "c"])
```

# Turner's Teaser

Define a function that determines whether another function
that accepts any number of Eithers always returns left.
Some say that this can be difficult with types.
Perhaps they are right; perhaps not.

As revealed by the name of the function `taut` -- [tautology](https://en.wikipedia.org/wiki/Tautology_(logic)),
and [chirsz](https://github.com/chirsz-ever)'s [zhihu article](https://zhuanlan.zhihu.com/p/133225452),
the aim of this question is to build a tautology tester for propositional logic.

Basic building blocks.

``` cicada
let Bool: Type = Either(Trivial, Trivial)
let true: Bool = inl(sole)
let false: Bool = inr(sole)
```

Type of proposition of any arity.

``` cicada
function Proposition(arity: Nat): Type {
  return nat_rec(
    arity,
    Bool,
    (_prev, almost) => (Bool) -> almost)
}

Proposition(0)
Proposition(1)
Proposition(2)
```

Logical connectives.

``` cicada
function and(a: Bool, b: Bool): Bool {
  return either_ind(
    a,
    (_) => Bool,
    (_) => b,
    (_) => false)
}

function or(a: Bool, b: Bool): Bool {
  return either_ind(
    a,
    (_) => Bool,
    (_) => true,
    (_) => b )
}

function not(a: Bool): Bool {
  return either_ind(
    a,
    (_) => Bool,
    (_) => false,
    (_) => true)
}

function if(a: Bool, b: Bool): Bool {
  return or(not(a), b)
}

function iff(a: Bool, b: Bool): Bool {
  return and(if(a, b), if(b, a))
}
```

Tautology tester.

``` cicada
function tautology_p(arity: Nat): (Proposition(arity)) -> Bool {
  function motive(target: Nat): Type {
    return (Proposition(target)) -> Bool
  }

  let base: (Bool) -> Bool = (bool) => bool

  function step(
    prev: Nat,
    almost: (Proposition(prev)) -> Bool,
  ): (Proposition(add1(prev))) -> Bool {
    return (p) => and(almost(p(true)), almost(p(false)))
  }

  return nat_ind(arity, motive, base, step)
}
```

Examples:

``` cicada
// non-tautologies:
tautology_p(1, not)
tautology_p(2, and)
tautology_p(2, or)

// tautologies:
tautology_p(1, (a) => or(a, not(a)))
tautology_p(1, (a) => if(a, a))
tautology_p(3, (a, b, c) => {
  return iff(if(and(a, b), c), if(a, if(b, c)))
})
```
