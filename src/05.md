---
title: 5. Lists, Lists, and More Lists
date: 2021-04-22
---

# Exercises

``` cicada
let expectations: List(String) = li! [
  "cooked",
  "eaten",
  "tried-cleaning",
  "understood",
  "slept"
]

expectations

List(String)
the(List(String), nil)
the(List(Nat), nil)
the(List(List(String)), nil)

the(List(String), li("a", li("b", li("c", nil))))
the(List(String), li! [ "a", "b", "c"])

function length_step(E: Type, _head: E, _tail: List(E), almost: Nat): Nat {
  return add1(almost)
}

function length(E: Type, x: List(E)): Nat {
  return list_rec(x, 0, length_step(E))
}

length(String)
length(String, expectations)

let append_t: Type = (E: Type, List(E), List(E)) -> List(E)

function append_step(E: Type, head: E, _tail: List(E), almost: List(E)): List(E) {
  return li(head, almost)
}

function append(E: Type, x: List(E), y: List(E)): List(E) {
  return list_rec(x, y, append_step(E))
}

append(Nat, li! [1, 2, 3], li! [4, 5, 6])

function li_end(E: Type, x: List(E), e: E): List(E) {
  return list_rec(x, li(e, nil), append_step(E))
}

li_end(Nat, li! [1, 2, 3], 4)

function reverse_step(E: Type, head: E, _tail: List(E), almost: List(E)): List(E) {
  return li_end(E, almost, head)
}

function reverse(E: Type, x: List(E)): List(E) {
  return list_rec(x, the(List(E), nil), reverse_step(E))
}

reverse(Nat, li! [1, 2, 3])

function append_by_reverse(E: Type, x: List(E), y: List(E)): List(E) {
  return list_rec(reverse(E, y), x, reverse_step(E))
}

append_by_reverse(Nat, li! [1, 2, 3], li! [4, 5, 6])
```

# Eliminators of Inductive types

In both cases,
the step accepts every argument
from the corresponding constructor
as well as the recursive elimination of the smaller value.

Eliminators expose the information in values.

- From the above principle, can we generate elim rules from intro rules?
