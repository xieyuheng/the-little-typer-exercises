---
title: 6. Precisely How Many?
date: 2021-05-06
---

# dependency

``` cicada
import { List } from "./05.md"
```

## zero_add1_equal_absurd

``` cicada
function nat_equal_consequence_t(x: Nat, y: Nat): Type {
  return nat_rec(
    x,
    nat_rec(
      y,
      Trivial,
      (_, _) => Absurd),
    (prev_x, _) =>
      nat_rec(
        y,
        Absurd,
        (prev_y, _) => Equal(Nat, prev_x, prev_y)))
}

function nat_equal_consequence_same(x: Nat): nat_equal_consequence_t(x, x) {
  return nat_ind(
    x,
    (target) => nat_equal_consequence_t(target, target),
    sole,
    (_prev, _almost) => refl)
}

function use_nat_equal(
  x: Nat, y: Nat,
  nat_equal: Equal(Nat, x, y),
): nat_equal_consequence_t(x, y) {
  function motive(n: Nat): Type {
    return nat_equal_consequence_t(x, n)
  }

  let base: motive(x) = nat_equal_consequence_same(x)

  return replace(nat_equal, motive, base)
}

function zero_add1_equal_absurd(n: Nat): (Equal(Nat, zero, add1(n))) -> Absurd {
  return use_nat_equal(zero, add1(n))
}
```

## sub1_equal

``` cicada
function sub1_equal(
  x: Nat, y: Nat,
): (Equal(Nat, add1(x), add1(y))) -> Equal(Nat, x, y) {
  return use_nat_equal(add1(x), add1(y))
}
```

# example vectors

``` cicada
the(Type, Vector(String, 0))
the(Type, Vector(String, 1))
the(Type, Vector(List(String), 0))
the(Type, Vector(List(String), 1))

the(Vector(String, 0), vecnil)
the(Vector(List(String), 0), vecnil)
the(Vector(List(List(String)), 0), vecnil)

the(Vector(String, 1), vec("a", vecnil))
the(Vector(String, 2), vec("a", vec("b", vecnil)))
```

# vector_head

``` cicada
function vector_head(
  implicit E: Type,
  implicit n: Nat,
  vector: Vector(E, add1(n))
): E {
  function motive(length: Nat, target: Vector(E, length)): Type {
    return (j: Nat, equal: Equal(Nat, length, add1(j))) -> E
  }

  let aux: motive(add1(n), vector) = {
    let base: motive(zero, vecnil) =
      (j, equal) => absurd_ind(zero_add1_equal_absurd(j, equal), E)

    function step(
      prev: Nat,
      head: E,
      tail: Vector(E, prev),
      almost: motive(prev, tail)
    ): motive(add1(prev), vec(head, tail)) {
      return (j, equal) => head
    }

    return vector_ind(add1(n), vector, motive, base, step)
  }

  return aux(n, refl)
}

vector_head(implicit Nat, implicit 0, vec! [1])
vector_head(implicit Nat, implicit 1, vec! [1, 2])
vector_head(implicit Nat, implicit 2, vec! [1, 2, 3])
vector_head(implicit Nat, implicit 3, vec! [1, 2, 3, 4])
```

# vector_tail

``` cicada
function vector_tail(
  implicit E: Type,
  implicit n: Nat,
  vector: Vector(E, add1(n))
): Vector(E, n) {
  function motive(length: Nat, target: Vector(E, length)): Type {
    return (j: Nat, equal: Equal(Nat, length, add1(j))) -> Vector(E, j)
  }

  let aux: motive(add1(n), vector) = {
    let base: motive(zero, vecnil) =
      (j, equal) => absurd_ind(zero_add1_equal_absurd(j, equal), Vector(E, j))

    function step(
      prev: Nat,
      head: E,
      tail: Vector(E, prev),
      almost: (j: Nat, equal: Equal(Nat, prev, add1(j))) -> Vector(E, j)
    ): (j: Nat, equal: Equal(Nat, add1(prev), add1(j))) -> Vector(E, j) {
      return (j, equal) => replace(sub1_equal(prev, j, equal), (x) => Vector(E, x) , tail)
    }

    return vector_ind(add1(n), vector, motive, base, step)
  }

  return aux(n, refl)
}

vector_tail(implicit Nat, implicit 0, vec! [1])
vector_tail(implicit Nat, implicit 1, vec! [1, 2])
vector_tail(implicit Nat, implicit 2, vec! [1, 2, 3])
vector_tail(implicit Nat, implicit 3, vec! [1, 2, 3, 4])
```

# type check or infer error

`infer` error is described as "exp is not described by a type", for example:

```
What is the value of
  (first-of-one Atom vecnil)?

That question is meaningless because
  (first-of-one Atom vecnil)
is not described by a type, and this is
because
  vecnil
is not a
  (Vec Atom 1).
```

# Use a More Specific Type

Make a function total by using a more specific type to
rule out unwanted arguments.
