---
title: 16. If It's All the Same to You
---

# `zero_equal_decide`

``` cicada
import { Decide, use_nat_equal } from "./15.md"

function zero_equal_decide(n: Nat): Decide(Equal(Nat, zero, n)) {
  function motive(target: Nat): Type {
    return Decide(Equal(Nat, zero, target))
  }

  let base: Decide(Equal(Nat, zero, zero)) = inl(refl)

  function step(
    prev: Nat,
    _almost: Decide(Equal(Nat, zero, prev)),
  ): Decide(Equal(Nat, zero, add1(prev))) {
    return inr((equal) => use_nat_equal(zero, add1(prev), equal))
  }

  return nat_ind(n, motive, base, step)
}

zero_equal_decide(0)
zero_equal_decide(1)
zero_equal_decide(2)
zero_equal_decide(3)
```

# `nat_equal_decide`

``` cicada
import { add } from "./03.md"
import { cong, cong_explicit } from "./08.md"
import { sub1_equal } from "./15.md"

function nat_equal_decide_motive(target: Nat): Type {
  return (j: Nat) -> Decide(Equal(Nat, target, j))
}

let nat_equal_decide_base: nat_equal_decide_motive(0) = (j) => zero_equal_decide(j)


function add1_equal_decide(
  x: Nat, y: Nat,
  eq_or_not: Decide(Equal(Nat, x, y)),
): Decide(Equal(Nat, add1(x), add1(y))) {
  return either_ind(
    eq_or_not,
    (_) => Decide(Equal(Nat, add1(x), add1(y))),
    (equal) => {
      // let h = cong_explicit(Nat, x, y, equal, Nat, add(1))
      let h = cong(equal, add(1))
      return inl(h)
    },
    (equal_absurd) => {
      return inr((equal) => equal_absurd(sub1_equal(x, y, equal)) )
    })
}

function nat_equal_decide_step(
  prev: Nat,
  almost: (j: Nat) -> Decide(Equal(Nat, prev, j)),
  j: Nat,
): Decide(Equal(Nat, add1(prev), j)) {
  function motive(target: Nat): Type {
    return Decide(Equal(Nat, add1(prev), target))
  }

  let base: Decide(Equal(Nat, add1(prev), zero)) =
    inr((equal) => use_nat_equal(add1(prev), zero, equal) )

  function step(
    prev_j: Nat,
    // NOTE This inner inductive hypothesis will not be used, use the outer one.
    _almost: Decide(Equal(Nat, add1(prev), prev_j)),
  ): Decide(Equal(Nat, add1(prev), add1(prev_j))) {
    return add1_equal_decide(prev, prev_j, almost(prev_j))
  }

  return nat_ind(j, motive, base, step)
}

function nat_equal_decide(n: Nat, j: Nat): Decide(Equal(Nat, n, j)) {
  return nat_ind(
    n,
    nat_equal_decide_motive,
    nat_equal_decide_base,
    nat_equal_decide_step
  )(j)
}

nat_equal_decide(0, 0)
nat_equal_decide(1, 0)
nat_equal_decide(0, 1)
nat_equal_decide(6, 4)
```
