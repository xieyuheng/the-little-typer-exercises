---
title: 2. Doin' What Comes Naturally
date: 2020-10-04
---

# Exercises

```cicada
function flavored_lentils(flavor: String): Pair(String, String) {
  return cons(flavor, "lentils")
}

let garlic_flavored_lentils: Pair(String, String) =
  flavored_lentils("garlic")

function id(x: String): String { return x }

let T: Type = Pair(String, (String) -> String)

function id_in_pair(x: String): T {
  return cons(x, (x) => x)
}

id_in_pair
the(T, id_in_pair("x"))

// The x occur in `(x) => x` should not be
// effected by the solutionitution of outer `x`,
// and `(x) => x` is equivalent to `(y) => y`,

the(
  Equal(
    T,
    id_in_pair("x"),
    cons("x", (y) => y)),
  refl)

the(
  Equal(
    (String) -> Pair(String, String),
    (x) => cons(x, x),
    (y) => cons(y, y)),
  refl)

the(
  Equal(
    (String) -> String,
    (y) => car(the(Pair(String, String), cons(y, y))),
    (x) => x),
  refl)

the(
  Equal(
    (Pair(String, String)) -> String,
    (y) => car(y),
    (x) => car(x)),
  refl)

let vegetables: Pair(String, String) =
  cons("celery", "carrot")

the(
  Equal(
    Pair(String, String),
    vegetables,
    cons(car(vegetables), cdr(vegetables))),
  refl)
```

# Nat

```cicada
datatype Nat {
  zero: Nat
  add1(prev: Nat): Nat
}

let zero = Nat.zero
let one = Nat.add1(zero)
let two = Nat.add1(one)
let three = Nat.add1(two)
let four = Nat.add1(three)
let five = Nat.add1(four)
let six = Nat.add1(five)
let seven = Nat.add1(six)
let eight = Nat.add1(seven)
let nine = Nat.add1(eight)
let ten = Nat.add1(nine)
```

# nat_ind

```cicada
function nat_ind(
  n: Nat,
  motive: (target: Nat) -> Type,
  base: motive(zero),
  step: (prev: Nat, almost_of_prev: motive(prev)) -> motive(Nat.add1(prev)),
): motive(n) {
  return induction (n) {
    motive
    case zero => base
    case add1(prev, almost) => step(prev, almost.prev)
  }
}
```

# nat_rec

```cicada
function nat_rec(
  n: Nat,
  implicit T: Type,
  base: T,
  step: (prev: Nat, almost_of_prev: T) -> T,
): T {
  return induction (n) {
    case zero => base
    case add1(prev, almost) => step(prev, almost.prev)
  }
}
```

# naught_or_more

```cicada
function naught_or_more(n: Nat): String {
  return nat_rec(n, "naught", (_prev, _almost) => "more")
}

the(Equal(String, naught_or_more(zero), "naught"), refl)
the(Equal(String, naught_or_more(one), "more"), refl)
the(Equal(String, naught_or_more(four), "more"), refl)
```

# Pear

```cicada
the(Pair(Type, Type), cons(String, String))

let Pear: Type = Pair(Nat, Nat)

the(Pear, cons(one, two))
```

# Definition of eliminator

In chapter 1, there are constructors, which build values,
and type constructors, which build types.

car, however, is neither a constructor nor a type constructor.

car is an eliminator.

Constructors build values, and eliminators
take apart values built by constructors.

Another way to see the difference is that
values contain information, and eliminators
allow that information to be used.

# Definition of substitution

Consistently replacing a variable with an expression
is sometimes called substitution.
